/*[# This is the original template, thus the warning below does not apply to this file #]
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains the toplevel handler for Fibre v0.1 endpoint operations.
 *
 * This endpoint-oriented approach will be deprecated in Fibre v0.2 in favor of
 * a function-oriented approach and a more powerful object model.
 *
 */
#ifndef __FIBRE_INTERFACES_HPP
#define __FIBRE_INTERFACES_HPP

namespace fibre {

const unsigned char embedded_json[] = [[embedded_endpoint_definitions | to_c_string]];
const size_t embedded_json_length = sizeof(embedded_json) - 1;
const uint16_t json_crc_ = calc_crc16<CANONICAL_CRC16_POLYNOMIAL>(PROTOCOL_VERSION, embedded_json, embedded_json_length);
const uint32_t json_version_id_ = (json_crc_ << 16) | calc_crc16<CANONICAL_CRC16_POLYNOMIAL>(json_crc_, embedded_json, embedded_json_length);

// Note: with -Og this function reserves a huge amount of stack space because it
// reserves separate space for the stack frame of each of the inlined functions.
// The minimum known set of flags to prevent this is `-O1 -fipa-sra`.
// `-O2` is a superset of this so that's what we use here.
bool endpoint_handler(int idx, cbufptr_t* input_buffer, bufptr_t* output_buffer) __attribute__ ((optimize(2)));

bool endpoint_handler(int idx, cbufptr_t* input_buffer, bufptr_t* output_buffer) {
    switch (idx) {
[%- for endpoint in endpoints %]
        case [[endpoint.id]]: { return [[endpoint.function.fullname | to_snake_case]]([% for k, arg in endpoint.function.in.items() %][% if k in endpoint.in_bindings %]static_cast<[[arg.type.c_type]]>([[endpoint.in_bindings[k]]])[% else %]std::nullopt[% endif %], [% endfor %][% for k, arg in endpoint.function.out.items() %][% if k in endpoint.out_bindings %]static_cast<[[arg.type.c_type]]*>([[endpoint.out_bindings[k]]])[% else %]nullptr[% endif %], [% endfor %]input_buffer, output_buffer); } break;
[%- endfor %]
        default: return false;
    }
}

bool is_endpoint_ref_valid(endpoint_ref_t endpoint_ref) {
    if (endpoint_ref.json_crc != json_crc_) {
        return false;
    }

    switch (endpoint_ref.endpoint_id) {
[%- for endpoint in endpoints %]
        case [[endpoint.id]]: return true;
[%- endfor %]
        default: return false;
    }
}

bool set_endpoint_from_float(endpoint_ref_t endpoint_ref, float value) {
    if (endpoint_ref.json_crc != json_crc_) {
        return false;
    }

    return false;
    // TODO: implement
    /*cbufptr_t input_buffer{};
    bufptr_t output_buffer{};

    switch (idx) {
[%- for endpoint in endpoints %]
        case [[endpoint.id]]: return [[endpoint.function.fullname | to_snake_case]]([% for k, arg in endpoint.function.in.items() %][% if k in endpoint.in_bindings %]static_cast<[[arg.type.c_type]]>([[endpoint.in_bindings[k]]])[% else %]std::nullopt[% endif %], [% endfor %]&input_buffer, &output_buffer);
[%- endfor %]
        default: return false;
    }*/
}

}

#endif // __FIBRE_INTERFACES_HPP