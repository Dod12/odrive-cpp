/*[# This is the original template, thus the warning below does not apply to this file #]
 * ============================ WARNING ============================
 * ==== This is an autogenerated file.                          ====
 * ==== Any changes to this file will be lost when recompiling. ====
 * =================================================================
 *
 * This file contains support functions for the ODrive ASCII protocol.
 *
 * TODO: might generalize this as an approach to runtime introspection.
 */

#include <fibre/introspection.hpp>

[% for intf in interfaces.values() %][% if not intf.builtin %]
template<typename T>
struct [[intf.fullname | to_pascal_case]]TypeInfo : TypeInfo {
    using TypeInfo::TypeInfo;
    static const PropertyInfo property_table[];
    static const [[intf.fullname | to_pascal_case]]TypeInfo<T> singleton;
    static Introspectable make_introspectable(T& obj) { return TypeInfo::make_introspectable(&obj, &singleton); }
};
[% endif %][% endfor %]

[% for intf in interfaces.values() %][% if not intf.builtin %]
template<typename T>
const PropertyInfo [[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table[] = {
[%- for property in intf.attributes.values() %]
    {"[[property.name]]", [](Introspectable& obj){ as<std::remove_reference_t<decltype([[intf.c_type]]::get_[[property.name]](std::declval<T*>()))>>(obj) = [[intf.c_type]]::get_[[property.name]](as<T*>(obj)); }, &[[(property.type.purename or property.type.fullname) | to_pascal_case]]TypeInfo<std::remove_reference_t<decltype(*[[intf.c_type]]::get_[[property.name]](std::declval<T*>()))>>::singleton},
[%- endfor %]
};
template<typename T>
const [[intf.fullname | to_pascal_case]]TypeInfo<T> [[intf.fullname | to_pascal_case]]TypeInfo<T>::singleton{[[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table, sizeof([[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table) / sizeof([[intf.fullname | to_pascal_case]]TypeInfo<T>::property_table[0])};

[% endif %][% endfor %]
